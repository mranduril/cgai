/////////////////////////////////////////////////////
//// CS 8803/4803 CGAI: Computer Graphics in AI Era
//// Assignment 1B: Neural SDF
/////////////////////////////////////////////////////

precision highp float;              //// set default precision of float variables to high precision

varying vec2 vUv;                   //// screen uv coordinates (varying, from vertex shader)
uniform vec2 iResolution;           //// screen resolution (uniform, from CPU)
uniform float iTime;                //// time elapsed (uniform, from CPU)

#define PI 3.1415925359

const vec3 CAM_POS = vec3(0, 1, 0);

vec3 rotate(vec3 p, vec3 ax, float ro)
{
    return mix(dot(p, ax) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);
}

struct material {
    float sdf;
    int id;
};

/////////////////////////////////////////////////////
//// sdf functions
/////////////////////////////////////////////////////

float sdfPlane(vec3 p, float h)
{
    return p.y - h;
}

float sdfBunny(vec3 p)
{
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI / 2. + PI / 1.);

    // sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if(length(p) > 1.0)
    {
        return length(p) - 0.9;
    }

    //// neural network weights for the bunny 

    vec4 f0_0=sin(p.y*vec4(1.74,-2.67,1.91,-1.93)+p.z*vec4(2.15,-3.05,.50,-1.32)+p.x*vec4(2.47,.30,-2.00,-2.75)+vec4(1.31,6.89,-8.25,.15));
    vec4 f0_1=sin(p.y*vec4(-.72,-3.13,4.36,-3.50)+p.z*vec4(3.39,3.58,-4.52,-1.10)+p.x*vec4(-1.02,-2.90,2.23,-.62)+vec4(1.61,-.84,-2.00,-.47));
    vec4 f0_2=sin(p.y*vec4(-1.47,.32,-.70,-1.51)+p.z*vec4(.17,.75,3.59,4.05)+p.x*vec4(-3.10,1.40,4.72,2.90)+vec4(-6.76,-6.43,2.41,-.66));
    vec4 f0_3=sin(p.y*vec4(-2.75,1.59,3.43,-3.39)+p.z*vec4(4.09,4.09,-2.34,1.23)+p.x*vec4(1.07,.65,-.18,-3.46)+vec4(-5.09,.73,3.06,3.35));
    vec4 f1_0=sin(mat4(.47,.12,-.23,-.04,.48,.06,-.24,.19,.12,.72,-.08,.39,.37,-.14,-.01,.06)*f0_0+
        mat4(-.62,-.40,-.81,-.30,-.34,.08,.26,.37,-.16,.38,-.09,.36,.02,-.50,.34,-.38)*f0_1+
        mat4(-.26,-.51,-.32,.32,-.67,.35,-.43,.93,.12,.34,.07,-.01,.67,.27,.43,-.02)*f0_2+
        mat4(.02,-.18,-.15,-.10,.47,-.07,.82,-.46,.18,.44,.39,-.94,-.20,-.28,-.20,.29)*f0_3+
        vec4(-.09,-3.49,2.17,-1.45))/1.0+f0_0;
    vec4 f1_1=sin(mat4(-.46,-.33,-.85,-.57,.41,.87,.25,.58,-.47,.16,-.14,-.06,-.70,-.82,-.20,.47)*f0_0+
        mat4(-.15,-.73,-.46,-.58,-.54,-.34,-.02,.12,.55,.32,.22,-.87,-.57,-.28,-.51,.10)*f0_1+
        mat4(.75,1.06,-.08,-.17,-.43,.69,1.07,.23,.46,-.02,.10,-.11,.21,-.70,-.08,-.48)*f0_2+
        mat4(.04,-.09,-.51,-.06,1.12,-.21,-.35,-.17,-.95,.49,.22,.99,.62,-.25,.06,-.20)*f0_3+
        vec4(-.61,2.91,-.17,.71))/1.0+f0_1;
    vec4 f1_2=sin(mat4(.01,-.86,-.07,.46,.73,-.28,.83,.12,.16,.33,.28,-.55,-.21,-.02,.53,-.15)*f0_0+
        mat4(-.28,-.32,.19,-.28,.24,-.23,-.61,-.39,.26,.40,.18,.41,.21,.57,-.91,-.29)*f0_1+
        mat4(.23,-.40,-1.34,-.50,.08,-.04,-1.67,-.16,-.65,-.09,.38,-.22,-.14,-.34,.37,.05)*f0_2+
        mat4(-.47,-.23,-.57,-.05,.51,.04,.00,.27,.80,.29,-.09,-.53,-.20,-.41,-.64,-.12)*f0_3+
        vec4(1.08,4.00,-2.54,2.18))/1.0+f0_2;
    vec4 f1_3=sin(mat4(-.30,.38,.39,.53,.73,.73,-.06,.01,.54,-.07,-.19,.68,.59,.40,.04,.07)*f0_0+
        mat4(-.17,.44,-.61,.43,-.84,-.12,.65,-.50,.33,-.31,-.28,.13,.18,-.42,.14,.08)*f0_1+
        mat4(-.78,.06,-.18,.37,-.99,.49,.71,.15,.27,-.48,-.17,.25,.05,.10,-.40,-.21)*f0_2+
        mat4(-.17,-.27,.40,.18,-.24,.23,.03,-.83,-.30,-.38,.07,.21,-.45,-.24,.78,.50)*f0_3+
        vec4(2.14,-3.48,3.81,-1.43))/1.0+f0_3;
    vec4 f2_0=sin(mat4(.83,.15,-.49,-.80,-.83,.16,1.24,.75,-.27,.18,-.13,1.05,.70,-.15,.30,.79)*f1_0+
        mat4(-.38,-.17,.34,.67,-.39,.09,.48,-.93,.19,.60,-.20,-.22,-.76,-.62,-.40,.01)*f1_1+
        mat4(.10,.22,.08,.13,-.42,-.11,.71,-.63,.02,.46,-.07,-.46,-.37,.07,.15,.14)*f1_2+
        mat4(.09,-.48,-.38,.40,-.57,-.88,-.14,-.25,.20,.95,.86,-1.08,.46,.04,.53,-.82)*f1_3+
        vec4(3.47,-3.66,3.06,.84))/1.4+f1_0;
    vec4 f2_1=sin(mat4(1.03,.03,-.76,-.03,.84,.66,-.49,.74,-.09,-.85,-.55,.17,.07,.85,-.55,-.20)*f1_0+
        mat4(-.55,1.13,.41,-.21,-.55,.19,.49,.67,.40,1.80,-.82,-.83,-1.02,.78,-.42,-.51)*f1_1+
        mat4(.77,-.88,.64,1.10,-.49,1.05,-.43,-.38,.66,-.63,.02,.11,-.24,-.23,.49,-.65)*f1_2+
        mat4(-.66,1.90,.02,-.48,.22,-.62,-.68,-.44,.52,-.57,.16,-.61,-.03,-.02,-.88,-.23)*f1_3+
        vec4(.58,-3.00,-2.53,.14))/1.4+f1_1;
    vec4 f2_2=sin(mat4(-.44,-.06,.30,-.37,.27,-.23,-.56,.15,.03,-.14,-.08,.72,.76,-.58,.55,.29)*f1_0+
        mat4(.31,.23,.42,-.17,.37,-.05,.39,.46,-1.14,.32,.06,-.28,.28,-.21,-.58,.62)*f1_1+
        mat4(.92,-.16,.86,-.09,-.12,.33,-.49,-.24,.29,-.19,.95,-.40,-.87,.08,.08,-.71)*f1_2+
        mat4(-.45,.67,1.07,-.14,-.56,.06,-.81,-.15,-.57,-.24,-1.09,.69,-.44,-.32,-.00,-.07)*f1_3+
        vec4(-4.43,-1.86,-2.87,1.45))/1.4+f1_2;
    vec4 f2_3=sin(mat4(.58,.25,.01,-.54,.34,.56,.61,-.79,-.01,.05,-.57,-1.31,.74,.78,-.10,-.11)*f1_0+
        mat4(-.03,-.48,-.24,.01,.10,.23,.22,-.05,.76,.29,-.37,.02,.54,-.07,.27,.38)*f1_1+
        mat4(.31,-1.03,.24,.95,.80,.29,.43,.61,-.04,-.22,-.06,-.52,-.46,.35,.07,-.07)*f1_2+
        mat4(.47,-.12,-.62,.06,.47,-.41,.53,-2.14,-.59,.16,.74,-.58,.32,.66,-.30,-.18)*f1_3+
        vec4(-2.86,-3.27,-.55,2.87))/1.4+f1_3;
    return dot(f2_0,vec4(-.08,.03,.07,-.03))+
        dot(f2_1,vec4(-.03,-.02,-.06,-.07))+
        dot(f2_2,vec4(.05,-.09,.03,.11))+
        dot(f2_3,vec4(.03,.06,-.06,-.03))+
        -0.014;
}

/////////////////////////////////////////////////////
//// Step 1: training a neural SDF model
//// You are asked to train your own neural SDF model on Colab. 
//// Your implementation should take place in neural_sdf.ipynb.
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 2: copy neural SDF weights to GLSL
//// In this step, you are asked to the network weights you have trained from the text file to the function sdfCow().
//// You should replace the default implementation (a sphere) with your own network weights. 
/////////////////////////////////////////////////////

float sdfCow(vec3 p)
{
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI / 3. + PI/3.0);

    // sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if(length(p) > 1.)
    {
        return length(p) - 0.9;
    }

    //// your implementation starts
    vec4 f0_0=sin(p.y*vec4(-3.01,2.17,3.83,2.85)+p.z*vec4(3.05,-.65,3.84,1.23)+p.x*vec4(1.52,-3.55,-2.66,1.17)+vec4(2.01,4.53,-1.51,-1.82));
    vec4 f0_1=sin(p.y*vec4(.16,.75,-1.51,1.73)+p.z*vec4(3.62,-2.55,2.20,.60)+p.x*vec4(1.15,-3.68,-2.58,4.26)+vec4(-5.44,8.27,-8.10,1.01));
    vec4 f0_2=sin(p.y*vec4(3.75,-2.67,.07,-2.24)+p.z*vec4(-.72,4.04,2.13,3.44)+p.x*vec4(3.37,-.56,-.37,-.17)+vec4(2.20,-6.90,-6.51,7.84));
    vec4 f0_3=sin(p.y*vec4(-3.27,-3.19,3.55,-2.76)+p.z*vec4(-4.86,-2.63,-1.71,.81)+p.x*vec4(-3.40,1.93,2.10,-2.34)+vec4(1.81,-7.93,3.96,-8.29));
    vec4 f1_0=sin(mat4(.05,.36,-.01,-.32,.27,-.40,.43,-.36,.16,.15,.12,.56,.40,.36,-.22,.18)*f0_0+
        mat4(.03,.35,.16,.18,.02,-.60,.17,-.26,-.29,-.44,.36,-.42,.13,-.07,-.25,.18)*f0_1+
        mat4(.35,-.10,-.31,-.71,-.56,.41,.46,.28,.62,-.01,.28,-.29,-.26,-.53,.74,-.18)*f0_2+
        mat4(-.08,.30,.04,.33,.25,-.52,-.12,-1.16,.18,-.03,.58,.74,-.72,.19,-.34,-.46)*f0_3+
        vec4(-2.96,-2.11,-1.42,-3.62))/1.0+f0_0;
    vec4 f1_1=sin(mat4(.58,.28,-.66,.03,-.03,-.43,-.46,.26,-.32,-.27,-.49,.26,.27,.55,-.45,.63)*f0_0+
        mat4(.12,.10,-.20,-.55,.39,-.96,.10,.75,-.08,-.26,.04,-.23,.30,-.26,.41,.36)*f0_1+
        mat4(.14,-.31,.32,.19,-.00,-.47,-.00,.56,-.86,-.50,-.45,.16,.15,-.55,-.53,.49)*f0_2+
        mat4(.15,-.27,-.15,.23,.63,-.51,.70,.11,-.09,-.19,-.32,.29,-.12,-.23,.24,-.47)*f0_3+
        vec4(-2.13,-1.13,-1.31,3.57))/1.0+f0_1;
    vec4 f1_2=sin(mat4(.65,.24,-.92,.13,-.45,.14,-.17,.74,.12,.29,.41,-.04,-.56,.23,-.05,.19)*f0_0+
        mat4(.73,-.56,.38,-.66,-.31,-.04,-.34,.41,.42,.56,.24,.26,-.36,-.31,-.13,-.15)*f0_1+
        mat4(-.36,.16,.02,.62,.48,.34,-.15,.21,.31,.14,.11,.04,.12,-.20,.09,-.01)*f0_2+
        mat4(-.03,-.23,-.32,.53,.45,-.04,-.12,.22,-.06,-.01,-.33,.52,.30,-.17,.22,.03)*f0_3+
        vec4(-3.52,-.63,-2.48,-3.37))/1.0+f0_2;
    vec4 f1_3=sin(mat4(.67,.00,.05,.21,-.27,.09,-.48,-.06,-.19,-.18,.43,.47,.42,-.19,.39,-.21)*f0_0+
        mat4(-.11,.12,-.24,.15,-.05,.69,-.20,.20,-.58,-.25,.05,.40,-.44,.04,-.04,-.52)*f0_1+
        mat4(.10,-.15,-.25,.10,.58,-.43,.18,.12,-1.13,-.65,-.05,-.27,.53,-.89,.89,-.08)*f0_2+
        mat4(.10,-.03,-.37,.32,-.22,-.49,-.99,-.60,.51,-.07,-.51,.12,-.11,-.17,-.29,-.41)*f0_3+
        vec4(-.83,-3.89,1.20,1.60))/1.0+f0_3;
    vec4 f2_0=sin(mat4(.01,.72,-.01,.18,.11,.08,-.20,-.47,.71,.03,.25,-.55,-.22,.08,.36,.27)*f1_0+
        mat4(-.83,.69,-.26,-.39,-.21,-.67,-.49,.47,.34,.18,.09,-.27,-.41,-.02,.16,.16)*f1_1+
        mat4(.02,.04,.24,.47,-.58,-.31,-.21,.58,-.27,-.35,.04,1.03,-.05,-.11,.38,.20)*f1_2+
        mat4(-.30,-.19,.33,.06,-.86,-1.02,.04,.83,-.91,-.49,.27,-.06,-.51,.33,-.60,-.67)*f1_3+
        vec4(.09,-.96,-1.60,1.12))/1.4+f1_0;
    vec4 f2_1=sin(mat4(-.04,.57,-.16,-.84,.10,.17,-.43,-.35,.22,-.32,.28,.26,-.30,.34,-.38,.76)*f1_0+
        mat4(.49,.50,-.10,.02,.06,-.51,-.09,.06,-.58,.03,-.79,.19,-.06,-.27,-.40,.12)*f1_1+
        mat4(.16,-.33,.62,-.57,.01,.39,-.57,-1.18,.09,.46,-.49,-.45,.69,-.59,.20,-.40)*f1_2+
        mat4(.26,.04,-.59,.26,-.33,-.26,.34,-.90,.29,.10,-.01,.19,-.36,.36,.51,-.93)*f1_3+
        vec4(-.62,2.06,-3.47,-1.68))/1.4+f1_1;
    vec4 f2_2=sin(mat4(.89,.43,-.30,-.26,-.10,-.58,-.09,.28,-.25,.29,-.45,-.36,.70,.39,-.74,-.28)*f1_0+
        mat4(-.15,-.07,.27,-.41,-.36,-.20,.12,.30,.02,-.70,-.67,.29,1.19,.25,.54,.57)*f1_1+
        mat4(-.02,-.31,-.51,-.31,.23,.41,.04,.76,.44,-.19,-.57,.99,.16,-.43,.78,-.02)*f1_2+
        mat4(-.18,.19,.23,.05,.15,-.09,.23,.47,.40,.20,.23,.13,-.76,-.24,.30,.52)*f1_3+
        vec4(-3.21,-2.85,.64,-1.89))/1.4+f1_2;
    vec4 f2_3=sin(mat4(.40,-.77,.47,-.33,.86,.10,.07,.49,-.37,-1.58,-1.35,-.04,-.26,.57,.27,.23)*f1_0+
        mat4(-.14,-.75,-.32,.19,-.11,-.42,.03,-.32,-.10,.05,.07,-.11,-.88,-.91,-.02,-.46)*f1_1+
        mat4(.20,-.58,.64,.85,.06,.93,.35,.21,.06,-.19,.25,.82,.27,-.03,1.32,.45)*f1_2+
        mat4(-.11,-.38,1.33,.44,.39,.28,.66,-.30,.72,-.02,.33,-.12,-.39,.63,-1.03,1.04)*f1_3+
        vec4(3.46,-2.31,2.02,.57))/1.4+f1_3;
    return dot(f2_0,vec4(-.08,-.04,-.08,.05))+
        dot(f2_1,vec4(-.06,-.08,-.05,-.03))+
        dot(f2_2,vec4(-.04,-.06,-.03,-.11))+
        dot(f2_3,vec4(-.06,.03,.02,.09))+
        -0.179;
    //// your implementation ends
}

float sdfTeddy(vec3 p)
{
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI / 3. + PI/3.0);

    // sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if(length(p) > 1.)
    {
        return length(p) - 0.9;
    }

    //// your implementation starts
    vec4 f0_0=sin(p.y*vec4(-2.65,1.81,2.05,2.75)+p.z*vec4(-2.51,-2.35,-1.12,3.02)+p.x*vec4(-1.86,3.89,.15,-2.08)+vec4(-5.23,5.30,1.33,6.90));
    vec4 f0_1=sin(p.y*vec4(.72,3.63,1.36,-2.38)+p.z*vec4(-2.69,3.50,3.80,.65)+p.x*vec4(-.39,1.94,-2.39,4.07)+vec4(2.61,7.14,7.95,6.57));
    vec4 f0_2=sin(p.y*vec4(-1.84,3.84,-4.05,-.56)+p.z*vec4(.38,1.90,-4.19,-.28)+p.x*vec4(.38,-.92,-1.64,2.86)+vec4(-3.70,1.72,.74,-1.68));
    vec4 f0_3=sin(p.y*vec4(-2.58,2.12,3.27,3.88)+p.z*vec4(4.76,1.64,-5.27,-4.49)+p.x*vec4(.45,3.10,.77,.42)+vec4(-8.53,-2.91,-4.10,5.74));
    vec4 f1_0=sin(mat4(-.18,-.11,-.17,-.26,-.51,-.43,-.32,-.00,-.55,-.31,-.51,-.36,-.11,.07,.02,.27)*f0_0+
        mat4(.70,.44,-.04,.42,.09,-.60,.37,.26,-.15,-.17,-1.08,-.34,.44,.62,-.00,.10)*f0_1+
        mat4(-.30,-.04,.36,.60,.35,-.64,.84,-.26,.20,-.07,.30,.01,-.54,-.11,-.87,.12)*f0_2+
        mat4(-.03,-.09,-.55,.41,-.25,-.35,.78,-.79,-.13,.10,.35,-.18,-.00,-.10,.08,-.61)*f0_3+
        vec4(-1.81,1.94,-3.09,-1.92))/1.0+f0_0;
    vec4 f1_1=sin(mat4(.14,.08,.04,.19,.34,-.08,.09,.16,.18,.05,-.08,-.31,.18,-.02,.13,.48)*f0_0+
        mat4(-.38,.01,.62,-.08,-.06,-.64,.49,.15,.83,.13,-.30,-.47,-.17,-.00,-.04,.92)*f0_1+
        mat4(-.41,-.07,.76,-.24,-.16,-.20,-.30,-.02,.36,-.69,.14,-.24,-.57,-.50,-1.13,-.04)*f0_2+
        mat4(.14,.08,.40,-.49,-.09,-.13,.06,-.83,-.05,-.26,-1.00,-.21,.52,-.50,-1.52,.27)*f0_3+
        vec4(2.41,-.15,-1.67,-3.49))/1.0+f0_1;
    vec4 f1_2=sin(mat4(.18,.35,-.26,.33,-.67,-.41,-.46,.05,.76,-.04,1.15,.92,.04,-.17,-.23,-.19)*f0_0+
        mat4(.86,-.59,.81,.01,-.37,-.41,.36,-.35,-.86,-.00,.25,.09,-1.20,.42,-.29,-.20)*f0_1+
        mat4(-.43,-.47,-.54,-.21,.38,.05,-.01,.20,-.07,-.45,-.92,-.04,.12,.55,-.52,-.25)*f0_2+
        mat4(.56,-.19,.22,.19,.25,-.54,.33,-.06,.25,.32,.20,.16,.01,-.08,.08,-.19)*f0_3+
        vec4(2.87,-.38,-.51,2.20))/1.0+f0_2;
    vec4 f1_3=sin(mat4(-.99,-.28,.01,-.31,.90,-.30,.47,-.25,-.13,-.32,-1.12,-.60,-.39,.58,-.44,.22)*f0_0+
        mat4(-.32,.09,.49,.55,-.26,.36,-.28,.65,.26,.40,.14,.16,-.53,.06,.05,-.05)*f0_1+
        mat4(-.99,-.12,-.33,.49,.46,.14,.04,.30,.63,.08,.76,.00,-.38,.07,-.17,.10)*f0_2+
        mat4(.63,.02,-.60,.05,-.08,-.52,.19,.27,-.05,-.01,.15,-.38,-.27,-.12,.26,-.04)*f0_3+
        vec4(1.98,-.74,-.74,-2.41))/1.0+f0_3;
    vec4 f2_0=sin(mat4(-.69,1.20,-.47,.69,.36,-.14,.04,-.57,-.06,.07,-.50,.09,-.52,-.86,.35,-.27)*f1_0+
        mat4(.06,1.02,.77,-.73,-.50,-1.18,-.15,-.88,.02,1.19,.01,-.23,-.18,.04,-.47,.94)*f1_1+
        mat4(-.47,.57,.50,-.39,-.26,-.02,.24,.47,-.94,.11,.16,-.18,-.79,-.31,.10,-.04)*f1_2+
        mat4(.19,-.49,-.66,-.32,.34,-1.29,.42,-.76,-.54,-.59,-.06,-.33,.24,-.71,.25,.13)*f1_3+
        vec4(-2.56,-3.98,1.15,-.32))/1.4+f1_0;
    vec4 f2_1=sin(mat4(-.17,-.15,-.42,1.40,-.06,-.38,-.10,-.26,-.16,.45,-.16,.24,-.70,.25,-.68,.80)*f1_0+
        mat4(.29,.16,-.26,-.15,-.04,.12,-.54,-.04,-.26,.18,-.21,.09,-.68,-.08,-1.20,.69)*f1_1+
        mat4(1.04,.05,.81,-.73,.64,-.51,-.48,-.43,1.06,-.15,-.12,-.58,.25,.36,.38,-.34)*f1_2+
        mat4(.61,.09,.32,-1.10,.74,.68,.93,-1.32,-.00,.36,-.54,-.86,-.64,.39,-.72,.10)*f1_3+
        vec4(2.48,-1.26,2.09,-3.83))/1.4+f1_1;
    vec4 f2_2=sin(mat4(.20,.36,-1.18,.27,.32,-.12,.68,-.65,-1.33,-.09,-.48,-.31,.07,-.55,-.29,-.42)*f1_0+
        mat4(.63,.08,.40,.27,.01,-.64,.01,-.19,.55,-.13,.35,.84,-.02,-.60,-1.09,-.57)*f1_1+
        mat4(-.40,.26,.40,.10,-.20,.29,1.26,.06,.27,-.14,.87,-.48,.42,.22,1.38,.17)*f1_2+
        mat4(-.55,.67,-.42,-.25,-.59,.94,.88,.96,-.38,.14,.76,.37,-.23,-.91,-.18,.70)*f1_3+
        vec4(-2.44,-2.76,-3.74,-3.89))/1.4+f1_2;
    vec4 f2_3=sin(mat4(-.76,-.02,-.37,-.28,-.06,.57,-.35,-.45,-.35,-.44,-.13,.11,.72,.26,-.26,.68)*f1_0+
        mat4(-.03,-.17,.28,-.21,.51,-.44,.26,-.28,.03,.26,-.72,-.32,-.09,-.09,.47,-.66)*f1_1+
        mat4(-.12,-.10,.65,.49,-.55,-.03,.68,-.45,-.42,.29,.97,-.10,1.20,.13,-.00,-.71)*f1_2+
        mat4(-.04,.04,-.62,.06,.20,.46,.33,.12,.12,-.35,.28,.10,-.05,-.41,-.54,.38)*f1_3+
        vec4(3.69,3.92,2.69,-.33))/1.4+f1_3;
    return dot(f2_0,vec4(-.04,.02,.04,-.04))+
        dot(f2_1,vec4(-.03,-.10,-.06,.04))+
        dot(f2_2,vec4(-.03,-.07,-.03,.11))+
        dot(f2_3,vec4(-.02,-.07,.02,-.06))+
        -0.109;
        //// your implementation ends
}

float sdfUnion(float d1, float d2)
{
    return min(d1, d2);
}

/////////////////////////////////////////////////////
//// Step 3: scene sdf
//// You are asked to use the sdf boolean operations to draw the bunny and the cow in the scene.
//// The bunny is located in the ceter of vec3(-1.0, 1., 4.), and the cow is located in the center of vec3(1.0, 1., 4.).
/////////////////////////////////////////////////////

//// sdf: p - query point
material sdf(vec3 p)
{
    float s = 0.;

    float plane_h = -0.1;

    //// calculate the sdf based on all objects in the scene

    //// your implementation starts
    float s_bunny = sdfBunny(p - vec3(-2.0, 1.0, 4.0));
    float s_cow = sdfCow(p - vec3(0.0, 1., 4.));
    float s_teddy = sdfTeddy(p - vec3(2., 1., 4.));
    float s_obj = sdfUnion(sdfUnion(s_bunny, s_cow), s_teddy);
    s = sdfUnion(s_obj, sdfPlane(p, plane_h));

    material m;
    m.sdf = s;
    m.id = 1;
    if (s_cow <= 0.002) m.id = 2;
    if (s_bunny <= 0.002) m.id = 3;
    if (s_teddy <= 0.002) m.id = 4;
    //// your implementation ends

    return m;
}

/////////////////////////////////////////////////////
//// ray marching
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 4: ray marching
//// You are asked to implement the ray marching algorithm within the following for-loop.
//// You are allowed to reuse your previous implementation in A1a for this function.
/////////////////////////////////////////////////////

//// ray marching: origin - ray origin; dir - ray direction 
float rayMarching(vec3 origin, vec3 dir)
{
    float s = 0.0;

    //// your implementation starts
    float delta = 0.0;
    for(int i = 0; i < 100; i++)
    {
        //// your implementation starts
        vec3 p = origin + dir * s;
        delta = sdf(p).sdf;
        s += delta;
        if (delta < 0.001 || s > 100.0) break;
        //// your implementation ends
    }
    //// your implementation ends

    return s;
}

/////////////////////////////////////////////////////
//// normal calculation
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 5: normal calculation
//// You are asked to calculate the sdf normal based on finite difference.
//// You are allowed to reuse your previous implementation in A1a for this function.
/////////////////////////////////////////////////////

//// normal: p - query point
vec3 normal(vec3 p)
{
    float s = sdf(p).sdf;          //// sdf value in p
    float dx = 0.01;           //// step size for finite difference

    //// your implementation starts
    return normalize(vec3(
        sdf(p + vec3(dx, 0.0, 0.0)).sdf - s,
        sdf(p + vec3(0.0, dx, 0.0)).sdf - s,
        sdf(p + vec3(0.0, 0.0, dx)).sdf - s));
    //// your implementation ends

    // return n;
}

/////////////////////////////////////////////////////
//// Phong shading
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 6: lighting and coloring
//// You are asked to specify the color for the two neural SDF objects in the scene.
//// Each object must have a separate color without mixing.
//// Notice that we have implemented the default Phong shading model for you.
/////////////////////////////////////////////////////

vec3 phong_shading(vec3 p, vec3 n)
{
    //// background
    if(p.z > 20.0)
    {
        vec3 color = vec3(0.04, 0.16, 0.33);
        return color;
    }

    //// phong shading
    vec3 lightPos = vec3(4. * sin(iTime), 4., 4. * cos(iTime));
    vec3 l = normalize(lightPos - p);
    float amb = 0.1;
    float dif = max(dot(n, l), 0.) * 0.7;
    vec3 eye = CAM_POS;
    float spec = pow(max(dot(reflect(-l, n), normalize(eye - p)), 0.0), 128.0) * 0.9;

    vec3 sunDir = normalize(vec3(0, 1, -1)); //// parallel light direction
    float sunDif = max(dot(n, sunDir), 0.) * 0.2;

    //// shadow
    float s = rayMarching(p + n * 0.02, l);
    if(s < length(lightPos - p))
        dif *= .2;

    vec3 color = vec3(1.0);

    //// your implementation starts
    material m = sdf(p);
    if (m.id == 1) color = vec3(0.6, 0.4, 0.1);
    if (m.id == 2) color = vec3(0.6, 0.2, 0.4); // cow
    if (m.id == 3) color = vec3(0.4, 0.6, 0.2); // bunny
    if (m.id == 4) color = vec3(0.2, 0.4, 0.5); // teddy
    //// your implementation ends

    return (amb + dif + spec + sunDif) * color;
}

/////////////////////////////////////////////////////
//// main function
/////////////////////////////////////////////////////

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;         //// screen uv
    vec3 origin = CAM_POS;                                                  //// camera position 
    vec3 dir = normalize(vec3(uv.x, uv.y, 1));                              //// camera direction
    float s = rayMarching(origin, dir);                                     //// ray marching
    vec3 p = origin + dir * s;                                              //// ray-sdf intersection
    vec3 n = normal(p);                                                     //// sdf normal
    vec3 color = phong_shading(p, n);                                       //// phong shading
    fragColor = vec4(color, 1.);                                            //// fragment color
}

void main()
{
    mainImage(gl_FragColor, gl_FragCoord.xy);
}